

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>adcircutils.mesh.mesh_merger &mdash; ADCIRC Utils 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            ADCIRC Utils
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../usage_guides.html">Usage Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../references.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">ADCIRC Utils</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">adcircutils.mesh.mesh_merger</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for adcircutils.mesh.mesh_merger</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Module for merging ADCIRC meshes with optional VEW boundary generation.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">argparse</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">adcircpy</span><span class="w"> </span><span class="kn">import</span> <span class="n">AdcircMesh</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Set</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="kn">import</span> <span class="n">cKDTree</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">adcircutils.mesh.vew_boundary_manipulator</span><span class="w"> </span><span class="kn">import</span> <span class="n">VEWBoundaryManipulator</span>


<div class="viewcode-block" id="MergeStrategy">
<a class="viewcode-back" href="../../../api/mesh.html#adcircutils.mesh.mesh_merger.MergeStrategy">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MergeStrategy</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Abstract base class for mesh merging strategies.&quot;&quot;&quot;</span>
    
<div class="viewcode-block" id="MergeStrategy.merge">
<a class="viewcode-back" href="../../../api/mesh.html#adcircutils.mesh.mesh_merger.MergeStrategy.merge">[docs]</a>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel_mesh</span><span class="p">:</span> <span class="n">AdcircMesh</span><span class="p">,</span> <span class="n">land_mesh</span><span class="p">:</span> <span class="n">AdcircMesh</span><span class="p">,</span> <span class="n">config</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AdcircMesh</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Merge two meshes according to the strategy.&quot;&quot;&quot;</span>
        <span class="k">pass</span></div>
</div>



<div class="viewcode-block" id="VEWBoundaryStrategy">
<a class="viewcode-back" href="../../../api/mesh.html#adcircutils.mesh.mesh_merger.VEWBoundaryStrategy">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">VEWBoundaryStrategy</span><span class="p">(</span><span class="n">MergeStrategy</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Strategy that keeps duplicate nodes and adds VEW boundaries.&quot;&quot;&quot;</span>
    
<div class="viewcode-block" id="VEWBoundaryStrategy._find_edges">
<a class="viewcode-back" href="../../../api/mesh.html#adcircutils.mesh.mesh_merger.VEWBoundaryStrategy._find_edges">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_find_edges</span><span class="p">(</span><span class="n">elements_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find all edges in the mesh and count how many elements each edge belongs to.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            elements_df: DataFrame containing element definitions</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            Dictionary mapping edges (as frozenset of node IDs) to the number of elements they belong to</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edge_counts</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">elements_df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="n">element</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="p">[</span>
                <span class="nb">frozenset</span><span class="p">([</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]]),</span>
                <span class="nb">frozenset</span><span class="p">([</span><span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">2</span><span class="p">]]),</span>
                <span class="nb">frozenset</span><span class="p">([</span><span class="n">nodes</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="p">]</span>
            
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
                <span class="n">edge_counts</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="k">return</span> <span class="n">edge_counts</span></div>


<div class="viewcode-block" id="VEWBoundaryStrategy._split_node_string">
<a class="viewcode-back" href="../../../api/mesh.html#adcircutils.mesh.mesh_merger.VEWBoundaryStrategy._split_node_string">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_split_node_string</span><span class="p">(</span><span class="n">nodes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> 
                          <span class="n">node_neighbors</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> 
                          <span class="n">elements_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Split a string of nodes into segments based on domain boundaries.&quot;&quot;&quot;</span>
        <span class="n">edge_counts</span> <span class="o">=</span> <span class="n">VEWBoundaryStrategy</span><span class="o">.</span><span class="n">_find_edges</span><span class="p">(</span><span class="n">elements_df</span><span class="p">)</span>
        
        <span class="n">segments</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">current_segment</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">processed</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">i</span><span class="p">])</span>
        
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">processed</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">):</span>
            <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
            
            <span class="c1"># Try to extend segment forward</span>
            <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="n">node_neighbors</span><span class="p">[</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]]:</span>
                <span class="k">if</span> <span class="n">jj</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="n">nodes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">jj</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">processed</span><span class="p">:</span>
                        <span class="n">edge</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">([</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nodes</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span>
                        <span class="k">if</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edge_counts</span> <span class="ow">and</span> <span class="n">edge_counts</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">current_segment</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                            <span class="n">processed</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                            <span class="n">i</span> <span class="o">=</span> <span class="n">j</span>
                            <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="k">break</span>

            <span class="c1"># If can&#39;t extend forward, try extending backward</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">found</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">current_segment</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">current_segment</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">current_segment</span><span class="p">))</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">current_segment</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="n">node_neighbors</span><span class="p">[</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]]:</span>
                    <span class="k">if</span> <span class="n">jj</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
                        <span class="n">j</span> <span class="o">=</span> <span class="n">nodes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">jj</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">processed</span><span class="p">:</span>
                            <span class="n">edge</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">([</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nodes</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span>
                            <span class="k">if</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edge_counts</span> <span class="ow">and</span> <span class="n">edge_counts</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                <span class="n">current_segment</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                                <span class="n">processed</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                                <span class="n">i</span> <span class="o">=</span> <span class="n">j</span>
                                <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                                <span class="k">break</span>

            <span class="c1"># If can&#39;t extend in either direction, start new segment</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
                <span class="c1"># Before starting a new segment, check if current segment forms an island</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">current_segment</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">first_node</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">current_segment</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                    <span class="n">last_node</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">current_segment</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="n">edge</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">([</span><span class="n">first_node</span><span class="p">,</span> <span class="n">last_node</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edge_counts</span> <span class="ow">and</span> <span class="n">edge_counts</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="c1"># This is an island - add the first node to close it</span>
                        <span class="n">current_segment</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_segment</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">current_segment</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_segment</span><span class="p">)</span>
                
                <span class="c1"># Find next unprocessed node</span>
                <span class="n">next_i</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">processed</span><span class="p">:</span>
                        <span class="n">next_i</span> <span class="o">=</span> <span class="n">idx</span>
                        <span class="k">break</span>
                        
                <span class="k">if</span> <span class="n">next_i</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">break</span>
                    
                <span class="n">i</span> <span class="o">=</span> <span class="n">next_i</span>
                <span class="n">current_segment</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">processed</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        
        <span class="c1"># Check the last segment for island closure</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">current_segment</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">first_node</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">current_segment</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">last_node</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">current_segment</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">([</span><span class="n">first_node</span><span class="p">,</span> <span class="n">last_node</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edge_counts</span> <span class="ow">and</span> <span class="n">edge_counts</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># This is an island - add the first node to close it</span>
                <span class="n">current_segment</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_segment</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        
        <span class="c1"># Add the last segment if it has more than one node</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">current_segment</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_segment</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">segments</span></div>


<div class="viewcode-block" id="VEWBoundaryStrategy._find_paired_nodes">
<a class="viewcode-back" href="../../../api/mesh.html#adcircutils.mesh.mesh_merger.VEWBoundaryStrategy._find_paired_nodes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_find_paired_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find pairs of nodes that are at identical locations.&quot;&quot;&quot;</span>
        <span class="n">paired_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">processed</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        
        <span class="n">coords</span> <span class="o">=</span> <span class="n">nodes_df</span><span class="p">[[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">processed</span><span class="p">:</span>
                <span class="k">continue</span>
                
            <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">coords</span> <span class="o">-</span> <span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">matches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">distances</span> <span class="o">&lt;</span> <span class="n">tolerance</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">i</span> <span class="ow">and</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">processed</span><span class="p">:</span>
                        <span class="n">paired_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
                        <span class="n">processed</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                <span class="n">processed</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">paired_nodes</span></div>


<div class="viewcode-block" id="VEWBoundaryStrategy._create_vew_boundaries">
<a class="viewcode-back" href="../../../api/mesh.html#adcircutils.mesh.mesh_merger.VEWBoundaryStrategy._create_vew_boundaries">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_create_vew_boundaries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                             <span class="n">paired_nodes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> 
                             <span class="n">land_mesh</span><span class="p">:</span> <span class="n">AdcircMesh</span><span class="p">,</span>
                             <span class="n">node_mapping</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
                             <span class="n">combined_elements</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
                             <span class="n">config</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create VEW boundary definitions.&quot;&quot;&quot;</span>
        <span class="n">nodes_land</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">paired_nodes</span><span class="p">]</span>
        <span class="n">nodes_channel</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">paired_nodes</span><span class="p">]</span>
        
        <span class="n">segments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split_node_string</span><span class="p">(</span>
            <span class="n">nodes_land</span><span class="p">,</span> 
            <span class="n">land_mesh</span><span class="o">.</span><span class="n">node_neighbors</span><span class="p">,</span> 
            <span class="n">combined_elements</span>
        <span class="p">)</span>
        
        <span class="n">vewboundaries</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">:</span>
            <span class="n">segment_pairs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">nodes_land</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nodes_channel</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">segment</span><span class="p">]</span>
            <span class="n">vew_node_id</span> <span class="o">=</span> <span class="p">[(</span><span class="nb">str</span><span class="p">(</span><span class="n">node1</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">node2</span><span class="p">))</span> <span class="k">for</span> <span class="n">node1</span><span class="p">,</span> <span class="n">node2</span> <span class="ow">in</span> <span class="n">segment_pairs</span><span class="p">]</span>
            
            <span class="n">vew_barrier_height</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">node1</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">segment_pairs</span><span class="p">:</span>
                <span class="n">elevation</span> <span class="o">=</span> <span class="p">(</span><span class="n">land_mesh</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">node1</span><span class="p">,</span> <span class="s1">&#39;value_1&#39;</span><span class="p">]</span> <span class="o">+</span> 
                           <span class="n">config</span><span class="p">[</span><span class="s1">&#39;height_offset&#39;</span><span class="p">])</span>
                <span class="n">vew_barrier_height</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elevation</span><span class="p">)</span>
            
            <span class="n">vewboundary</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;node_id&#39;</span><span class="p">:</span> <span class="n">vew_node_id</span><span class="p">,</span>
                <span class="s1">&#39;barrier_height&#39;</span><span class="p">:</span> <span class="n">vew_barrier_height</span><span class="p">,</span>
                <span class="s1">&#39;subcritical_flow_coefficient&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;subcritical_coefficient&#39;</span><span class="p">]]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">segment_pairs</span><span class="p">),</span>
                <span class="s1">&#39;supercritical_flow_coefficient&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;supercritical_coefficient&#39;</span><span class="p">]]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">segment_pairs</span><span class="p">)</span>
            <span class="p">}</span>
            
            <span class="n">vewboundaries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vewboundary</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">vewboundaries</span></div>


<div class="viewcode-block" id="VEWBoundaryStrategy._filter_boundary_nodes">
<a class="viewcode-back" href="../../../api/mesh.html#adcircutils.mesh.mesh_merger.VEWBoundaryStrategy._filter_boundary_nodes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_filter_boundary_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">original_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">matching_nodes</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Filter out nodes that are members of matching nodes from a boundary.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            node_ids: List of node IDs in the boundary</span>
<span class="sd">            original_length: Original length of the boundary</span>
<span class="sd">            matching_nodes: Set of node IDs that match between the two meshes</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            Tuple of (list of indices to keep, whether to keep the boundary)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Find indices of nodes to keep (not in matching_nodes)</span>
        <span class="n">keep_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node_id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node_ids</span><span class="p">)</span> <span class="k">if</span> <span class="n">node_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">matching_nodes</span><span class="p">]</span>
        
        <span class="c1"># If all nodes are removed, don&#39;t keep the boundary</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">keep_indices</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[],</span> <span class="kc">False</span>
            
        <span class="c1"># Add one node before and after the filtered section if possible</span>
        <span class="k">if</span> <span class="n">keep_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">keep_indices</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">keep_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">keep_indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">original_length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">keep_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">keep_indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            
        <span class="c1"># If only one node remains, don&#39;t keep the boundary</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keep_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[],</span> <span class="kc">False</span>
            
        <span class="c1"># If the boundary is reduced to just its endpoints, don&#39;t keep it</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keep_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">keep_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">keep_indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">original_length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[],</span> <span class="kc">False</span>
            
        <span class="k">return</span> <span class="n">keep_indices</span><span class="p">,</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="VEWBoundaryStrategy.merge">
<a class="viewcode-back" href="../../../api/mesh.html#adcircutils.mesh.mesh_merger.VEWBoundaryStrategy.merge">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel_mesh</span><span class="p">:</span> <span class="n">AdcircMesh</span><span class="p">,</span> <span class="n">land_mesh</span><span class="p">:</span> <span class="n">AdcircMesh</span><span class="p">,</span> <span class="n">config</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AdcircMesh</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Merge meshes using VEW boundaries.&quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Starting mesh merge with VEW boundaries...&quot;</span><span class="p">)</span>
        
        <span class="c1"># Get the number of nodes in the land mesh</span>
        <span class="n">land_node_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">land_mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
        
        <span class="c1"># Create node mapping</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Creating node mapping...&quot;</span><span class="p">)</span>
        <span class="n">node_mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">old_id</span><span class="p">:</span> <span class="n">new_id</span> <span class="k">for</span> <span class="n">old_id</span><span class="p">,</span> <span class="n">new_id</span> <span class="ow">in</span> 
                       <span class="nb">zip</span><span class="p">(</span><span class="n">channel_mesh</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> 
                           <span class="nb">range</span><span class="p">(</span><span class="n">land_node_count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> 
                                <span class="n">land_node_count</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">channel_mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))}</span>
        
        <span class="c1"># Combine nodes</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Combining nodes...&quot;</span><span class="p">)</span>
        <span class="n">channel_nodes</span> <span class="o">=</span> <span class="n">channel_mesh</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">channel_nodes</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="n">node_mapping</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">channel_nodes</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
        <span class="n">combined_nodes</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">land_mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">channel_nodes</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Combined nodes: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">combined_nodes</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="c1"># Combine elements</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Combining elements...&quot;</span><span class="p">)</span>
        <span class="n">channel_elements</span> <span class="o">=</span> <span class="n">channel_mesh</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">channel_elements</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">channel_elements</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">channel_elements</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">node_mapping</span><span class="p">)</span>
        <span class="n">combined_elements</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">land_mesh</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">elements</span><span class="p">,</span> <span class="n">channel_elements</span><span class="p">])</span>
        <span class="c1"># Reset element IDs to be 1-based</span>
        <span class="n">combined_elements</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">combined_elements</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Combined elements: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">combined_elements</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="c1"># Find matching nodes</span>
        <span class="n">manipulator</span> <span class="o">=</span> <span class="n">VEWBoundaryManipulator</span><span class="p">()</span>
        <span class="n">matching_nodes</span> <span class="o">=</span> <span class="n">manipulator</span><span class="o">.</span><span class="n">find_matching_nodes</span><span class="p">(</span>
            <span class="n">channel_mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> 
            <span class="n">land_mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> 
            <span class="n">config</span><span class="p">[</span><span class="s1">&#39;tolerance&#39;</span><span class="p">]</span>
        <span class="p">)</span>
        
        <span class="c1"># Update boundaries of channel mesh</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Updating boundary node numbers...&quot;</span><span class="p">)</span>
        <span class="n">boundaries_new</span> <span class="o">=</span> <span class="n">channel_mesh</span><span class="o">.</span><span class="n">boundaries</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ibtype</span> <span class="ow">in</span> <span class="n">boundaries_new</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">boundaries_ibtype_new</span> <span class="o">=</span> <span class="n">boundaries_new</span><span class="p">[</span><span class="n">ibtype</span><span class="p">]</span>
            
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">boundaries_ibtype_new</span><span class="p">)):</span>
                <span class="n">node_ids</span> <span class="o">=</span> <span class="n">boundaries_ibtype_new</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;node_id&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">ibtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># open boundary</span>
                    <span class="n">node_ids1</span> <span class="o">=</span> <span class="n">node_ids</span>
                <span class="k">elif</span> <span class="n">ibtype</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;4&#39;</span><span class="p">):</span> <span class="c1"># weir boundary</span>
                    <span class="n">node_ids1</span> <span class="o">=</span> <span class="p">[</span><span class="n">node_id</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">node_id</span> <span class="ow">in</span> <span class="n">node_ids</span><span class="p">]</span>
                    <span class="n">node_ids2</span> <span class="o">=</span> <span class="p">[</span><span class="n">node_id</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">node_id</span> <span class="ow">in</span> <span class="n">node_ids</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># other boundaries</span>
                    <span class="n">node_ids1</span> <span class="o">=</span> <span class="n">node_ids</span>
                    
                <span class="n">boundary_new</span> <span class="o">=</span> <span class="n">boundaries_ibtype_new</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                
                <span class="k">if</span> <span class="n">ibtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># open boundary</span>
                    <span class="n">new_node_ids</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">node_mapping</span><span class="p">[</span><span class="n">nid</span><span class="p">])</span> <span class="k">for</span> <span class="n">nid</span> <span class="ow">in</span> <span class="n">node_ids</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">ibtype</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;4&#39;</span><span class="p">):</span> <span class="c1"># weir boundary</span>
                    <span class="n">new_node_ids</span> <span class="o">=</span> <span class="p">[(</span><span class="nb">str</span><span class="p">(</span><span class="n">node_mapping</span><span class="p">[</span><span class="n">node_ids1</span><span class="p">[</span><span class="n">j</span><span class="p">]]),</span> <span class="nb">str</span><span class="p">(</span><span class="n">node_mapping</span><span class="p">[</span><span class="n">node_ids2</span><span class="p">[</span><span class="n">j</span><span class="p">]]))</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">node_ids</span><span class="p">))]</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># other boundaries</span>
                    <span class="n">new_node_ids</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">node_mapping</span><span class="p">[</span><span class="n">nid</span><span class="p">])</span> <span class="k">for</span> <span class="n">nid</span> <span class="ow">in</span> <span class="n">node_ids</span><span class="p">]</span>
                    
                <span class="n">boundary_new</span><span class="p">[</span><span class="s1">&#39;node_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_node_ids</span>

        <span class="c1"># Merge land mesh boundaries and channel mesh boundaries</span>
        <span class="n">boundaries_land</span> <span class="o">=</span> <span class="n">land_mesh</span><span class="o">.</span><span class="n">boundaries</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ibtype</span> <span class="ow">in</span> <span class="n">land_mesh</span><span class="o">.</span><span class="n">boundaries</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">boundaries_land</span><span class="p">[</span><span class="n">ibtype</span><span class="p">])):</span>
                <span class="k">if</span> <span class="n">ibtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># open boundary</span>
                    <span class="n">boundaries_land</span><span class="p">[</span><span class="n">ibtype</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;node_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span> <span class="k">for</span> <span class="n">nid</span> <span class="ow">in</span> <span class="n">boundaries_land</span><span class="p">[</span><span class="n">ibtype</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;node_id&#39;</span><span class="p">]]</span>
                <span class="k">elif</span> <span class="n">ibtype</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;4&#39;</span><span class="p">):</span> <span class="c1"># weir boundary</span>
                    <span class="n">boundaries_land</span><span class="p">[</span><span class="n">ibtype</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;node_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="nb">str</span><span class="p">(</span><span class="n">nid</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">str</span><span class="p">(</span><span class="n">nid</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="k">for</span> <span class="n">nid</span> <span class="ow">in</span> <span class="n">boundaries_land</span><span class="p">[</span><span class="n">ibtype</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;node_id&#39;</span><span class="p">]]</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># other boundaries</span>
                    <span class="n">boundaries_land</span><span class="p">[</span><span class="n">ibtype</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;node_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span> <span class="k">for</span> <span class="n">nid</span> <span class="ow">in</span> <span class="n">boundaries_land</span><span class="p">[</span><span class="n">ibtype</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;node_id&#39;</span><span class="p">]]</span>

            <span class="k">if</span> <span class="n">ibtype</span> <span class="ow">in</span> <span class="n">boundaries_new</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">boundaries_new</span><span class="p">[</span><span class="n">ibtype</span><span class="p">]</span> <span class="o">=</span> <span class="n">boundaries_land</span><span class="p">[</span><span class="n">ibtype</span><span class="p">]</span> <span class="o">+</span> <span class="n">boundaries_new</span><span class="p">[</span><span class="n">ibtype</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">boundaries_new</span><span class="p">[</span><span class="n">ibtype</span><span class="p">]</span> <span class="o">=</span> <span class="n">boundaries_land</span><span class="p">[</span><span class="n">ibtype</span><span class="p">]</span>

        <span class="c1"># Remove nodes that are members of matching nodes from the merged boundaries</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Removing matching nodes from boundaries...&quot;</span><span class="p">)</span>
        <span class="c1"># Create a set of all matching nodes (both from land and channel mesh)</span>
        <span class="c1"># For channel mesh nodes (keys), use the mapped IDs</span>
        <span class="n">matching_node_strings</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">node_mapping</span><span class="p">[</span><span class="n">nid</span><span class="p">])</span> <span class="k">for</span> <span class="n">nid</span> <span class="ow">in</span> <span class="n">matching_nodes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span> <span class="k">for</span> <span class="n">nid</span> <span class="ow">in</span> <span class="n">matching_nodes</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">ibtype</span> <span class="ow">in</span> <span class="n">boundaries_new</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">boundaries_ibtype</span> <span class="o">=</span> <span class="n">boundaries_new</span><span class="p">[</span><span class="n">ibtype</span><span class="p">]</span>
            <span class="n">new_boundaries</span> <span class="o">=</span> <span class="p">[]</span>
            
            <span class="k">for</span> <span class="n">boundary</span> <span class="ow">in</span> <span class="n">boundaries_ibtype</span><span class="p">:</span>
                <span class="n">node_ids</span> <span class="o">=</span> <span class="n">boundary</span><span class="p">[</span><span class="s1">&#39;node_id&#39;</span><span class="p">]</span>
                <span class="n">original_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_ids</span><span class="p">)</span>
                
                <span class="c1"># Extract first side of nodes for all boundary types</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
                    <span class="n">node_ids1</span> <span class="o">=</span> <span class="p">[</span><span class="n">node_id</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">node_id</span> <span class="ow">in</span> <span class="n">node_ids</span><span class="p">]</span>
                    <span class="n">node_ids2</span> <span class="o">=</span> <span class="p">[</span><span class="n">node_id</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">node_id</span> <span class="ow">in</span> <span class="n">node_ids</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">node_ids1</span> <span class="o">=</span> <span class="n">node_ids</span>
                
                <span class="c1"># Filter nodes once for all boundary types</span>
                <span class="n">keep_indices</span><span class="p">,</span> <span class="n">should_keep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter_boundary_nodes</span><span class="p">(</span><span class="n">node_ids1</span><span class="p">,</span> <span class="n">original_length</span><span class="p">,</span> <span class="n">matching_node_strings</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="n">should_keep</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">ibtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># open boundary</span>
                        <span class="n">boundary</span><span class="p">[</span><span class="s1">&#39;node_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">node_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">keep_indices</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="n">ibtype</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;4&#39;</span><span class="p">):</span> <span class="c1"># weir boundary</span>
                        <span class="n">boundary</span><span class="p">[</span><span class="s1">&#39;node_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">node_ids1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">node_ids2</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">keep_indices</span><span class="p">]</span>
                        <span class="c1"># Filter other weir parameters using the same indices</span>
                        <span class="n">boundary</span><span class="p">[</span><span class="s1">&#39;barrier_height&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">boundary</span><span class="p">[</span><span class="s1">&#39;barrier_height&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">keep_indices</span><span class="p">]</span>
                        <span class="n">boundary</span><span class="p">[</span><span class="s1">&#39;subcritical_flow_coefficient&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">boundary</span><span class="p">[</span><span class="s1">&#39;subcritical_flow_coefficient&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">keep_indices</span><span class="p">]</span>
                        <span class="n">boundary</span><span class="p">[</span><span class="s1">&#39;supercritical_flow_coefficient&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">boundary</span><span class="p">[</span><span class="s1">&#39;supercritical_flow_coefficient&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">keep_indices</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span> <span class="c1"># other boundaries</span>
                        <span class="n">boundary</span><span class="p">[</span><span class="s1">&#39;node_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">node_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">keep_indices</span><span class="p">]</span>
                    <span class="n">new_boundaries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">boundary</span><span class="p">)</span>
            
            <span class="n">boundaries_new</span><span class="p">[</span><span class="n">ibtype</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_boundaries</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Creating final merged mesh...&quot;</span><span class="p">)</span>
        <span class="n">merged_mesh</span> <span class="o">=</span> <span class="n">AdcircMesh</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="n">combined_nodes</span><span class="p">,</span> <span class="n">elements</span><span class="o">=</span><span class="n">combined_elements</span><span class="p">,</span> <span class="n">boundaries</span><span class="o">=</span><span class="n">boundaries_new</span><span class="p">)</span>
        
        <span class="c1"># Add VEW boundaries</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Finding paired nodes...&quot;</span><span class="p">)</span>
        <span class="n">paired_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_paired_nodes</span><span class="p">(</span><span class="n">merged_mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;tolerance&#39;</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">paired_nodes</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">paired_nodes</span><span class="p">)</span><span class="si">}</span><span class="s2"> paired nodes&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Creating VEW boundaries...&quot;</span><span class="p">)</span>
            <span class="n">vewboundaries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_vew_boundaries</span><span class="p">(</span>
                <span class="n">paired_nodes</span><span class="p">,</span> 
                <span class="n">land_mesh</span><span class="p">,</span>
                <span class="n">node_mapping</span><span class="p">,</span>
                <span class="n">combined_elements</span><span class="p">,</span>
                <span class="n">config</span>
            <span class="p">)</span>
            
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Adding VEW boundaries to mesh...&quot;</span><span class="p">)</span>
            <span class="n">boundaries</span> <span class="o">=</span> <span class="n">merged_mesh</span><span class="o">.</span><span class="n">boundaries</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
            <span class="k">if</span> <span class="s1">&#39;64&#39;</span> <span class="ow">in</span> <span class="n">boundaries</span><span class="p">:</span>
                <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;64&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">vewboundaries</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;64&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">vewboundaries</span>
            
            <span class="n">merged_mesh</span> <span class="o">=</span> <span class="n">AdcircMesh</span><span class="p">(</span>
                <span class="n">nodes</span><span class="o">=</span><span class="n">merged_mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span>
                <span class="n">elements</span><span class="o">=</span><span class="n">merged_mesh</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">elements</span><span class="p">,</span>
                <span class="n">boundaries</span><span class="o">=</span><span class="n">boundaries</span>
            <span class="p">)</span>
            
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Added </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">vewboundaries</span><span class="p">)</span><span class="si">}</span><span class="s2"> VEW boundary segments&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No paired nodes found for VEW boundaries&quot;</span><span class="p">)</span>
            
 
        <span class="k">if</span> <span class="s1">&#39;64&#39;</span> <span class="ow">in</span> <span class="n">boundaries</span><span class="p">:</span>
            <span class="c1"># Merge endpoints of non-looped VEW boundaries</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Merging endpoints of non-looped VEW boundaries...&quot;</span><span class="p">)</span>

            <span class="c1"># Create a list of endpoints of VEW boundaries that are not looped</span>
            <span class="n">endpoint_pairs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">vew_boundaries</span> <span class="o">=</span> <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;64&#39;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">boundary</span> <span class="ow">in</span> <span class="n">vew_boundaries</span><span class="p">:</span>
                <span class="n">node_ids</span> <span class="o">=</span> <span class="n">boundary</span><span class="p">[</span><span class="s1">&#39;node_id&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_ids</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="c1"># Check if the boundary is non-looped</span>
                    <span class="k">if</span> <span class="n">node_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">node_ids</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="c1"># Create a list of node pairs</span>
                        <span class="n">endpoint_pairs</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">node_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">node_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                        <span class="n">endpoint_pairs</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">node_ids</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">node_ids</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">endpoints_land</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">endpoint_pairs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">endpoints_land_str</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">endpoints_land</span><span class="p">]</span>
            
            <span class="c1"># Update elevations at the endpoint land nodes to the mean of the land and channel nodes</span>
            <span class="k">if</span> <span class="n">endpoint_pairs</span><span class="p">:</span>
                <span class="n">new_nodes</span> <span class="o">=</span> <span class="n">merged_mesh</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">new_elements</span> <span class="o">=</span> <span class="n">merged_mesh</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">boundaries</span> <span class="o">=</span> <span class="n">merged_mesh</span><span class="o">.</span><span class="n">boundaries</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                
                <span class="k">for</span> <span class="n">land_node</span><span class="p">,</span> <span class="n">channel_node</span> <span class="ow">in</span> <span class="n">endpoint_pairs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">new_nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">land_node</span><span class="p">,</span> <span class="s1">&#39;value_1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">land_node</span><span class="p">,</span> <span class="s1">&#39;value_1&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">new_nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">channel_node</span><span class="p">,</span> <span class="s1">&#39;value_1&#39;</span><span class="p">])</span> <span class="o">*</span> <span class="mf">0.5</span>
                    
                <span class="c1"># Drop the endpoint channel nodes</span>
                <span class="n">new_nodes</span> <span class="o">=</span> <span class="n">new_nodes</span><span class="p">[</span><span class="o">~</span><span class="n">new_nodes</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">endpoint_pairs</span><span class="o">.</span><span class="n">values</span><span class="p">())]</span>
                
                <span class="c1"># Create a node mapping</span>
                <span class="n">node_mapping</span> <span class="o">=</span> <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">i_old</span><span class="p">):</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">i_old</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new_nodes</span><span class="o">.</span><span class="n">index</span><span class="p">)}</span>
                <span class="k">for</span> <span class="n">land_node</span><span class="p">,</span> <span class="n">channel_node</span> <span class="ow">in</span> <span class="n">endpoint_pairs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">node_mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">channel_node</span><span class="p">)]</span> <span class="o">=</span> <span class="n">node_mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">land_node</span><span class="p">)]</span>
                <span class="n">node_mapping_int</span> <span class="o">=</span> <span class="p">{</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">):</span> <span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">node_mapping</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
                    
                <span class="c1"># Update the index of the combined_nodes</span>
                <span class="n">new_nodes</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_nodes</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                
                <span class="c1"># Update the node indices in new_elements</span>
                <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">new_elements</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                    <span class="n">new_elements</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_elements</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">node_mapping_int</span><span class="p">)</span>
                
                <span class="c1"># Update the boundaries</span>
                <span class="n">new_boundaries</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">ibtype</span> <span class="ow">in</span> <span class="n">boundaries</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">ibtype</span> <span class="o">==</span> <span class="s1">&#39;64&#39;</span><span class="p">:</span>
                        <span class="n">boundaries_ibtype</span> <span class="o">=</span> <span class="n">boundaries</span><span class="p">[</span><span class="n">ibtype</span><span class="p">]</span>
                        <span class="n">new_boundaries_ibtype</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">boundary</span> <span class="ow">in</span> <span class="n">boundaries_ibtype</span><span class="p">:</span>
                            <span class="n">keep_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">nid</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">boundary</span><span class="p">[</span><span class="s1">&#39;node_id&#39;</span><span class="p">])</span> <span class="k">if</span> <span class="n">nid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">endpoints_land_str</span><span class="p">]</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keep_indices</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                                <span class="c1"># Get the filtered node pairs using keep_indices</span>
                                <span class="n">filtered_node_pairs</span> <span class="o">=</span> <span class="p">[</span><span class="n">boundary</span><span class="p">[</span><span class="s1">&#39;node_id&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">keep_indices</span><span class="p">]</span>
                                <span class="n">filtered_barrier_heights</span> <span class="o">=</span> <span class="p">[</span><span class="n">boundary</span><span class="p">[</span><span class="s1">&#39;barrier_height&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">keep_indices</span><span class="p">]</span>
                                <span class="n">filtered_subcrit</span> <span class="o">=</span> <span class="p">[</span><span class="n">boundary</span><span class="p">[</span><span class="s1">&#39;subcritical_flow_coefficient&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">keep_indices</span><span class="p">]</span>
                                <span class="n">filtered_supercrit</span> <span class="o">=</span> <span class="p">[</span><span class="n">boundary</span><span class="p">[</span><span class="s1">&#39;supercritical_flow_coefficient&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">keep_indices</span><span class="p">]</span>
                                
                                <span class="c1"># Create new boundary with mapped node IDs</span>
                                <span class="n">boundary</span><span class="p">[</span><span class="s1">&#39;node_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">node_mapping</span><span class="p">[</span><span class="n">nid</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">node_mapping</span><span class="p">[</span><span class="n">nid</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span> <span class="k">for</span> <span class="n">nid</span> <span class="ow">in</span> <span class="n">filtered_node_pairs</span><span class="p">]</span>
                                <span class="n">boundary</span><span class="p">[</span><span class="s1">&#39;barrier_height&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">filtered_barrier_heights</span>
                                <span class="n">boundary</span><span class="p">[</span><span class="s1">&#39;subcritical_flow_coefficient&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">filtered_subcrit</span>
                                <span class="n">boundary</span><span class="p">[</span><span class="s1">&#39;supercritical_flow_coefficient&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">filtered_supercrit</span>
                                <span class="n">new_boundaries_ibtype</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">boundary</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">new_boundaries_ibtype</span><span class="p">:</span>
                            <span class="n">new_boundaries</span><span class="p">[</span><span class="n">ibtype</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_boundaries_ibtype</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">boundaries_ibtype</span> <span class="o">=</span> <span class="n">boundaries</span><span class="p">[</span><span class="n">ibtype</span><span class="p">]</span>
                        <span class="n">new_boundaries_ibtype</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">boundary</span> <span class="ow">in</span> <span class="n">boundaries_ibtype</span><span class="p">:</span>
                            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">boundary</span><span class="p">[</span><span class="s1">&#39;node_id&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
                                <span class="n">boundary</span><span class="p">[</span><span class="s1">&#39;node_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">node_mapping</span><span class="p">[</span><span class="n">nid</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">node_mapping</span><span class="p">[</span><span class="n">nid</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span> <span class="k">for</span> <span class="n">nid</span> <span class="ow">in</span> <span class="n">boundary</span><span class="p">[</span><span class="s1">&#39;node_id&#39;</span><span class="p">]]</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">boundary</span><span class="p">[</span><span class="s1">&#39;node_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">node_mapping</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span> <span class="k">for</span> <span class="n">nid</span> <span class="ow">in</span> <span class="n">boundary</span><span class="p">[</span><span class="s1">&#39;node_id&#39;</span><span class="p">]]</span>
                            <span class="n">new_boundaries_ibtype</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">boundary</span><span class="p">)</span>
                        <span class="n">new_boundaries</span><span class="p">[</span><span class="n">ibtype</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_boundaries_ibtype</span>
                
                <span class="n">merged_mesh</span> <span class="o">=</span> <span class="n">AdcircMesh</span><span class="p">(</span>
                    <span class="n">nodes</span><span class="o">=</span><span class="n">new_nodes</span><span class="p">,</span>
                    <span class="n">elements</span><span class="o">=</span><span class="n">new_elements</span><span class="p">,</span>
                    <span class="n">boundaries</span><span class="o">=</span><span class="n">new_boundaries</span>
                <span class="p">)</span>
        
        <span class="c1"># Reorder the boundaries to have the VEW boundaries last</span>
        <span class="n">boundaries</span> <span class="o">=</span> <span class="n">merged_mesh</span><span class="o">.</span><span class="n">boundaries</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
        <span class="k">if</span> <span class="s1">&#39;64&#39;</span> <span class="ow">in</span> <span class="n">boundaries</span><span class="p">:</span>
            <span class="n">vew_boundaries</span> <span class="o">=</span> <span class="n">boundaries</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;64&#39;</span><span class="p">)</span>
            <span class="n">boundaries</span><span class="p">[</span><span class="s1">&#39;64&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">vew_boundaries</span>           
        
        <span class="n">merged_mesh</span> <span class="o">=</span> <span class="n">AdcircMesh</span><span class="p">(</span>
            <span class="n">nodes</span><span class="o">=</span><span class="n">merged_mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span>
            <span class="n">elements</span><span class="o">=</span><span class="n">merged_mesh</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">elements</span><span class="p">,</span>
            <span class="n">boundaries</span><span class="o">=</span><span class="n">boundaries</span>
        <span class="p">)</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Mesh merge complete!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">merged_mesh</span></div>
</div>



<div class="viewcode-block" id="MergedNodesStrategy">
<a class="viewcode-back" href="../../../api/mesh.html#adcircutils.mesh.mesh_merger.MergedNodesStrategy">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MergedNodesStrategy</span><span class="p">(</span><span class="n">MergeStrategy</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Strategy that merges duplicate nodes at boundaries.&quot;&quot;&quot;</span>
    
<div class="viewcode-block" id="MergedNodesStrategy.merge">
<a class="viewcode-back" href="../../../api/mesh.html#adcircutils.mesh.mesh_merger.MergedNodesStrategy.merge">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel_mesh</span><span class="p">:</span> <span class="n">AdcircMesh</span><span class="p">,</span> <span class="n">land_mesh</span><span class="p">:</span> <span class="n">AdcircMesh</span><span class="p">,</span> <span class="n">config</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AdcircMesh</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Merge meshes by merging duplicate nodes.&quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Starting mesh merge with node merging...&quot;</span><span class="p">)</span>
        
        <span class="c1"># Find matching nodes</span>
        <span class="n">manipulator</span> <span class="o">=</span> <span class="n">VEWBoundaryManipulator</span><span class="p">()</span>
        <span class="n">matching_nodes</span> <span class="o">=</span> <span class="n">manipulator</span><span class="o">.</span><span class="n">find_matching_nodes</span><span class="p">(</span>
            <span class="n">channel_mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> 
            <span class="n">land_mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> 
            <span class="n">config</span><span class="p">[</span><span class="s1">&#39;tolerance&#39;</span><span class="p">]</span>
        <span class="p">)</span>
        
        <span class="c1"># Create node mapping for non-matching nodes</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Creating node mapping...&quot;</span><span class="p">)</span>
        <span class="n">land_node_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">land_mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
        <span class="n">node_mapping</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">next_node_id</span> <span class="o">=</span> <span class="n">land_node_count</span> <span class="o">+</span> <span class="mi">1</span>
        
        <span class="k">for</span> <span class="n">old_id</span> <span class="ow">in</span> <span class="n">channel_mesh</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">old_id</span> <span class="ow">in</span> <span class="n">matching_nodes</span><span class="p">:</span>
                <span class="c1"># Use existing node ID from land mesh</span>
                <span class="n">node_mapping</span><span class="p">[</span><span class="n">old_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">matching_nodes</span><span class="p">[</span><span class="n">old_id</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Assign new node ID</span>
                <span class="n">node_mapping</span><span class="p">[</span><span class="n">old_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">next_node_id</span>
                <span class="n">next_node_id</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="c1"># Start with a copy of the land mesh nodes</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Combining nodes...&quot;</span><span class="p">)</span>
        <span class="n">combined_nodes</span> <span class="o">=</span> <span class="n">land_mesh</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># Update values for matching nodes based on configuration</span>
        <span class="k">if</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;use_channel_values&#39;</span><span class="p">]:</span>
            <span class="n">source_mesh</span> <span class="o">=</span> <span class="n">channel_mesh</span>
            <span class="n">source_ids</span> <span class="o">=</span> <span class="n">matching_nodes</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="n">target_ids</span> <span class="o">=</span> <span class="n">matching_nodes</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
            <span class="n">value_source</span> <span class="o">=</span> <span class="s2">&quot;channel&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">source_mesh</span> <span class="o">=</span> <span class="n">land_mesh</span>
            <span class="n">source_ids</span> <span class="o">=</span> <span class="n">matching_nodes</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
            <span class="n">target_ids</span> <span class="o">=</span> <span class="n">matching_nodes</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
            <span class="n">value_source</span> <span class="o">=</span> <span class="s2">&quot;land&quot;</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Updating values at matching nodes using </span><span class="si">{</span><span class="n">value_source</span><span class="si">}</span><span class="s2"> mesh values...&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">source_id</span><span class="p">,</span> <span class="n">target_id</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">source_ids</span><span class="p">,</span> <span class="n">target_ids</span><span class="p">):</span>
            <span class="n">combined_nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">target_id</span><span class="p">,</span> <span class="s1">&#39;value_1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">source_mesh</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">source_id</span><span class="p">,</span> <span class="s1">&#39;value_1&#39;</span><span class="p">]</span>
        
        <span class="c1"># Add non-matching nodes from channel mesh</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Adding non-matching nodes...&quot;</span><span class="p">)</span>
        <span class="n">new_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">old_id</span> <span class="ow">in</span> <span class="n">channel_mesh</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">old_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">matching_nodes</span><span class="p">:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">channel_mesh</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">old_id</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">node_mapping</span><span class="p">[</span><span class="n">old_id</span><span class="p">]</span>
                <span class="n">new_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">new_nodes</span><span class="p">:</span>
            <span class="n">new_nodes_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">new_nodes</span><span class="p">)</span>
            <span class="n">combined_nodes</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">combined_nodes</span><span class="p">,</span> <span class="n">new_nodes_df</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Combined nodes: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">combined_nodes</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="c1"># Update element connectivity</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Updating element connectivity...&quot;</span><span class="p">)</span>
        <span class="n">channel_elements</span> <span class="o">=</span> <span class="n">channel_mesh</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">channel_elements</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">channel_elements</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">channel_elements</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">node_mapping</span><span class="p">)</span>
        
        <span class="n">combined_elements</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">land_mesh</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">elements</span><span class="p">,</span> <span class="n">channel_elements</span><span class="p">])</span>
        <span class="c1"># Reset element IDs to be 1-based</span>
        <span class="n">combined_elements</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">combined_elements</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Combined elements: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">combined_elements</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="c1"># Update boundaries of channel mesh</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Updating boundary node numbers...&quot;</span><span class="p">)</span>
        <span class="n">boundaries_new</span> <span class="o">=</span> <span class="n">channel_mesh</span><span class="o">.</span><span class="n">boundaries</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ibtype</span> <span class="ow">in</span> <span class="n">boundaries_new</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">boundaries_ibtype_new</span> <span class="o">=</span> <span class="n">boundaries_new</span><span class="p">[</span><span class="n">ibtype</span><span class="p">]</span>
            
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">boundaries_ibtype_new</span><span class="p">)):</span>
                <span class="n">node_ids</span> <span class="o">=</span> <span class="n">boundaries_ibtype_new</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;node_id&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">ibtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># open boundary</span>
                    <span class="n">node_ids1</span> <span class="o">=</span> <span class="n">node_ids</span>
                <span class="k">elif</span> <span class="n">ibtype</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;4&#39;</span><span class="p">):</span> <span class="c1"># weir boundary</span>
                    <span class="n">node_ids1</span> <span class="o">=</span> <span class="p">[</span><span class="n">node_id</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">node_id</span> <span class="ow">in</span> <span class="n">node_ids</span><span class="p">]</span>
                    <span class="n">node_ids2</span> <span class="o">=</span> <span class="p">[</span><span class="n">node_id</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">node_id</span> <span class="ow">in</span> <span class="n">node_ids</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># other boundaries</span>
                    <span class="n">node_ids1</span> <span class="o">=</span> <span class="n">node_ids</span>
                    
                <span class="n">boundary_new</span> <span class="o">=</span> <span class="n">boundaries_ibtype_new</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                
                <span class="k">if</span> <span class="n">ibtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># open boundary</span>
                    <span class="n">new_node_ids</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">node_mapping</span><span class="p">[</span><span class="n">nid</span><span class="p">])</span> <span class="k">for</span> <span class="n">nid</span> <span class="ow">in</span> <span class="n">node_ids</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">ibtype</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;4&#39;</span><span class="p">):</span> <span class="c1"># weir boundary</span>
                    <span class="n">new_node_ids</span> <span class="o">=</span> <span class="p">[(</span><span class="nb">str</span><span class="p">(</span><span class="n">node_mapping</span><span class="p">[</span><span class="n">node_ids1</span><span class="p">[</span><span class="n">j</span><span class="p">]]),</span> <span class="nb">str</span><span class="p">(</span><span class="n">node_mapping</span><span class="p">[</span><span class="n">node_ids2</span><span class="p">[</span><span class="n">j</span><span class="p">]]))</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">node_ids</span><span class="p">))]</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># other boundaries</span>
                    <span class="n">new_node_ids</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">node_mapping</span><span class="p">[</span><span class="n">nid</span><span class="p">])</span> <span class="k">for</span> <span class="n">nid</span> <span class="ow">in</span> <span class="n">node_ids</span><span class="p">]</span>
                    
                <span class="n">boundary_new</span><span class="p">[</span><span class="s1">&#39;node_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_node_ids</span>

        <span class="c1"># Merge land mesh boundaries and channel mesh boundaries</span>
        <span class="n">boundaries_land</span> <span class="o">=</span> <span class="n">land_mesh</span><span class="o">.</span><span class="n">boundaries</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ibtype</span> <span class="ow">in</span> <span class="n">land_mesh</span><span class="o">.</span><span class="n">boundaries</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">boundaries_land</span><span class="p">[</span><span class="n">ibtype</span><span class="p">])):</span>
                <span class="k">if</span> <span class="n">ibtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># open boundary</span>
                    <span class="n">boundaries_land</span><span class="p">[</span><span class="n">ibtype</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;node_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span> <span class="k">for</span> <span class="n">nid</span> <span class="ow">in</span> <span class="n">boundaries_land</span><span class="p">[</span><span class="n">ibtype</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;node_id&#39;</span><span class="p">]]</span>
                <span class="k">elif</span> <span class="n">ibtype</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;4&#39;</span><span class="p">):</span> <span class="c1"># weir boundary</span>
                    <span class="n">boundaries_land</span><span class="p">[</span><span class="n">ibtype</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;node_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="nb">str</span><span class="p">(</span><span class="n">nid</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">str</span><span class="p">(</span><span class="n">nid</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="k">for</span> <span class="n">nid</span> <span class="ow">in</span> <span class="n">boundaries_land</span><span class="p">[</span><span class="n">ibtype</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;node_id&#39;</span><span class="p">]]</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># other boundaries</span>
                    <span class="n">boundaries_land</span><span class="p">[</span><span class="n">ibtype</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;node_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span> <span class="k">for</span> <span class="n">nid</span> <span class="ow">in</span> <span class="n">boundaries_land</span><span class="p">[</span><span class="n">ibtype</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;node_id&#39;</span><span class="p">]]</span>

            <span class="k">if</span> <span class="n">ibtype</span> <span class="ow">in</span> <span class="n">boundaries_new</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">boundaries_new</span><span class="p">[</span><span class="n">ibtype</span><span class="p">]</span> <span class="o">=</span> <span class="n">boundaries_land</span><span class="p">[</span><span class="n">ibtype</span><span class="p">]</span> <span class="o">+</span> <span class="n">boundaries_new</span><span class="p">[</span><span class="n">ibtype</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">boundaries_new</span><span class="p">[</span><span class="n">ibtype</span><span class="p">]</span> <span class="o">=</span> <span class="n">boundaries_land</span><span class="p">[</span><span class="n">ibtype</span><span class="p">]</span>

        <span class="c1"># Find boundary edges in the final mesh</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Finding boundary edges in final mesh...&quot;</span><span class="p">)</span>
        <span class="n">edge_counts</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">combined_elements</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="n">element</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="p">[</span>
                <span class="nb">frozenset</span><span class="p">([</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]]),</span>
                <span class="nb">frozenset</span><span class="p">([</span><span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">2</span><span class="p">]]),</span>
                <span class="nb">frozenset</span><span class="p">([</span><span class="n">nodes</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="p">]</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
                <span class="n">edge_counts</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Create set of boundary nodes (nodes that belong to edges with count 1)</span>
        <span class="n">boundary_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">edge</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">edge_counts</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">boundary_nodes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>

        <span class="c1"># Remove non-boundary nodes from the merged boundaries</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Removing non-boundary nodes...&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ibtype</span> <span class="ow">in</span> <span class="n">boundaries_new</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">boundaries_ibtype</span> <span class="o">=</span> <span class="n">boundaries_new</span><span class="p">[</span><span class="n">ibtype</span><span class="p">]</span>
            <span class="n">new_boundaries</span> <span class="o">=</span> <span class="p">[]</span>
            
            <span class="k">for</span> <span class="n">boundary</span> <span class="ow">in</span> <span class="n">boundaries_ibtype</span><span class="p">:</span>
                <span class="n">node_ids</span> <span class="o">=</span> <span class="n">boundary</span><span class="p">[</span><span class="s1">&#39;node_id&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">ibtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># open boundary</span>
                    <span class="c1"># Only keep nodes that are on the boundary</span>
                    <span class="n">node_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">nid</span> <span class="k">for</span> <span class="n">nid</span> <span class="ow">in</span> <span class="n">node_ids</span> <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span> <span class="ow">in</span> <span class="n">boundary_nodes</span><span class="p">]</span>
                    <span class="c1"># Only keep node strings with at least 2 nodes</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_ids</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="c1"># Check if the string has been reduced to just endpoints</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_ids</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">boundary</span><span class="p">[</span><span class="s1">&#39;node_id&#39;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
                            <span class="c1"># Skip this boundary as it&#39;s been reduced to just endpoints</span>
                            <span class="k">continue</span>
                        <span class="n">boundary</span><span class="p">[</span><span class="s1">&#39;node_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_ids</span>
                        <span class="n">new_boundaries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">boundary</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">ibtype</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;4&#39;</span><span class="p">):</span> <span class="c1"># weir boundary</span>
                    <span class="n">node_ids1</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">node_id</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">node_id</span> <span class="ow">in</span> <span class="n">node_ids</span><span class="p">]</span>
                    <span class="n">node_ids2</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">node_id</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">node_id</span> <span class="ow">in</span> <span class="n">node_ids</span><span class="p">]</span>
                    <span class="c1"># Only keep nodes that are on the boundary</span>
                    <span class="n">keep_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">node_ids1</span><span class="p">,</span> <span class="n">node_ids2</span><span class="p">))</span> 
                                  <span class="k">if</span> <span class="n">n1</span> <span class="ow">in</span> <span class="n">boundary_nodes</span> <span class="ow">and</span> <span class="n">n2</span> <span class="ow">in</span> <span class="n">boundary_nodes</span><span class="p">]</span>
                    <span class="c1"># Only keep weir segments where both sides have nodes</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keep_indices</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="c1"># Check if either side has been reduced to just endpoints</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keep_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">boundary</span><span class="p">[</span><span class="s1">&#39;node_id&#39;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
                            <span class="c1"># Skip this boundary as one side has been reduced to just endpoints</span>
                            <span class="k">continue</span>
                        <span class="n">boundary</span><span class="p">[</span><span class="s1">&#39;node_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="nb">str</span><span class="p">(</span><span class="n">node_ids1</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="nb">str</span><span class="p">(</span><span class="n">node_ids2</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">keep_indices</span><span class="p">]</span>
                        <span class="c1"># Filter other weir parameters using the same indices</span>
                        <span class="n">boundary</span><span class="p">[</span><span class="s1">&#39;barrier_height&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">boundary</span><span class="p">[</span><span class="s1">&#39;barrier_height&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">keep_indices</span><span class="p">]</span>
                        <span class="n">boundary</span><span class="p">[</span><span class="s1">&#39;subcritical_flow_coefficient&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">boundary</span><span class="p">[</span><span class="s1">&#39;subcritical_flow_coefficient&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">keep_indices</span><span class="p">]</span>
                        <span class="n">boundary</span><span class="p">[</span><span class="s1">&#39;supercritical_flow_coefficient&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">boundary</span><span class="p">[</span><span class="s1">&#39;supercritical_flow_coefficient&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">keep_indices</span><span class="p">]</span>
                        <span class="n">new_boundaries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">boundary</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># other boundaries</span>
                    <span class="c1"># Only keep nodes that are on the boundary</span>
                    <span class="n">node_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">nid</span> <span class="k">for</span> <span class="n">nid</span> <span class="ow">in</span> <span class="n">node_ids</span> <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span> <span class="ow">in</span> <span class="n">boundary_nodes</span><span class="p">]</span>
                    <span class="c1"># Only keep node strings with at least 2 nodes</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_ids</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="c1"># Check if the string has been reduced to just endpoints</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_ids</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">boundary</span><span class="p">[</span><span class="s1">&#39;node_id&#39;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
                            <span class="c1"># Skip this boundary as it&#39;s been reduced to just endpoints</span>
                            <span class="k">continue</span>
                        <span class="n">boundary</span><span class="p">[</span><span class="s1">&#39;node_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_ids</span>
                        <span class="n">new_boundaries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">boundary</span><span class="p">)</span>
            
            <span class="n">boundaries_new</span><span class="p">[</span><span class="n">ibtype</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_boundaries</span>
        
        <span class="c1"># Reorder the boundaries to have the VEW boundaries last</span>
        <span class="k">if</span> <span class="s1">&#39;64&#39;</span> <span class="ow">in</span> <span class="n">boundaries_new</span><span class="p">:</span>
            <span class="n">vew_boundaries</span> <span class="o">=</span> <span class="n">boundaries_new</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;64&#39;</span><span class="p">)</span>
            <span class="n">boundaries_new</span><span class="p">[</span><span class="s1">&#39;64&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">vew_boundaries</span>           
        
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Creating final merged mesh...&quot;</span><span class="p">)</span>
        <span class="n">merged_mesh</span> <span class="o">=</span> <span class="n">AdcircMesh</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="n">combined_nodes</span><span class="p">,</span> <span class="n">elements</span><span class="o">=</span><span class="n">combined_elements</span><span class="p">,</span> <span class="n">boundaries</span><span class="o">=</span><span class="n">boundaries_new</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Merged </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">matching_nodes</span><span class="p">)</span><span class="si">}</span><span class="s2"> duplicate nodes&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Used </span><span class="si">{</span><span class="n">value_source</span><span class="si">}</span><span class="s2"> mesh values at </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">matching_nodes</span><span class="p">)</span><span class="si">}</span><span class="s2"> matching nodes&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Mesh merge complete!&quot;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">merged_mesh</span></div>
</div>



<div class="viewcode-block" id="MeshMerger">
<a class="viewcode-back" href="../../../api/mesh.html#adcircutils.mesh.mesh_merger.MeshMerger">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MeshMerger</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class for merging ADCIRC meshes with configurable strategies.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="MeshMerger.__init__">
<a class="viewcode-back" href="../../../api/mesh.html#adcircutils.mesh.mesh_merger.MeshMerger.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel_mesh</span><span class="p">:</span> <span class="n">AdcircMesh</span><span class="p">,</span> <span class="n">land_mesh</span><span class="p">:</span> <span class="n">AdcircMesh</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize the mesh merger with channel and land meshes.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_channel_mesh</span> <span class="o">=</span> <span class="n">channel_mesh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_land_mesh</span> <span class="o">=</span> <span class="n">land_mesh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_config</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_default_config</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_strategy</span> <span class="o">=</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="MeshMerger._create_default_config">
<a class="viewcode-back" href="../../../api/mesh.html#adcircutils.mesh.mesh_merger.MeshMerger._create_default_config">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_create_default_config</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create default configuration for mesh merging.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;tolerance&#39;</span><span class="p">:</span> <span class="mf">1e-6</span><span class="p">,</span>
            <span class="s1">&#39;height_offset&#39;</span><span class="p">:</span> <span class="mf">0.001</span><span class="p">,</span>
            <span class="s1">&#39;subcritical_coefficient&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
            <span class="s1">&#39;supercritical_coefficient&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
            <span class="s1">&#39;use_channel_values&#39;</span><span class="p">:</span> <span class="kc">True</span>  <span class="c1"># Default to using channel mesh values</span>
        <span class="p">}</span></div>


    <span class="c1"># Builder methods</span>
<div class="viewcode-block" id="MeshMerger.with_tolerance">
<a class="viewcode-back" href="../../../api/mesh.html#adcircutils.mesh.mesh_merger.MeshMerger.with_tolerance">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">with_tolerance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;MeshMerger&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the tolerance for node matching.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="p">[</span><span class="s1">&#39;tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tolerance</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="MeshMerger.with_height_offset">
<a class="viewcode-back" href="../../../api/mesh.html#adcircutils.mesh.mesh_merger.MeshMerger.with_height_offset">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">with_height_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;MeshMerger&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the height offset for VEW boundaries.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="p">[</span><span class="s1">&#39;height_offset&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">offset</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="MeshMerger.with_flow_coefficients">
<a class="viewcode-back" href="../../../api/mesh.html#adcircutils.mesh.mesh_merger.MeshMerger.with_flow_coefficients">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">with_flow_coefficients</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subcritical</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">supercritical</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;MeshMerger&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the flow coefficients for VEW boundaries.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="p">[</span><span class="s1">&#39;subcritical_coefficient&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">subcritical</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="p">[</span><span class="s1">&#39;supercritical_coefficient&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">supercritical</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="MeshMerger.with_channel_values">
<a class="viewcode-back" href="../../../api/mesh.html#adcircutils.mesh.mesh_merger.MeshMerger.with_channel_values">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">with_channel_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">enabled</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;MeshMerger&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Choose whether to use channel mesh values at matching nodes.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="p">[</span><span class="s1">&#39;use_channel_values&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">enabled</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="MeshMerger.merge">
<a class="viewcode-back" href="../../../api/mesh.html#adcircutils.mesh.mesh_merger.MeshMerger.merge">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">boundary_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;merge&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AdcircMesh</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Merge the meshes using the selected strategy.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">boundary_mode</span> <span class="o">==</span> <span class="s2">&quot;vew&quot;</span><span class="p">:</span>
            <span class="n">strategy</span> <span class="o">=</span> <span class="n">VEWBoundaryStrategy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># &quot;merge&quot;</span>
            <span class="n">strategy</span> <span class="o">=</span> <span class="n">MergedNodesStrategy</span><span class="p">()</span>
            
        <span class="k">return</span> <span class="n">strategy</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_channel_mesh</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_land_mesh</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="main">
<a class="viewcode-back" href="../../../api/mesh.html#adcircutils.mesh.mesh_merger.main">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Main function to handle command line arguments and process the meshes.&quot;&quot;&quot;</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Merge ADCIRC meshes with optional VEW boundary generation&quot;</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;channelmesh&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Path to the channel mesh file&quot;</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;landmesh&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Path to the land mesh file&quot;</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s1">&#39;-o&#39;</span><span class="p">,</span> <span class="s1">&#39;--output&#39;</span><span class="p">,</span>
        <span class="n">default</span><span class="o">=</span><span class="s1">&#39;merged_mesh.grd&#39;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Path to save the merged mesh (default: merged_mesh.grd)&#39;</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s1">&#39;-d&#39;</span><span class="p">,</span> <span class="s1">&#39;--description&#39;</span><span class="p">,</span>
        <span class="n">default</span><span class="o">=</span><span class="s1">&#39;merged&#39;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Description for the merged mesh (default: merged)&#39;</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;-b&quot;</span><span class="p">,</span> <span class="s2">&quot;--boundary-mode&quot;</span><span class="p">,</span>
        <span class="n">choices</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;merge&quot;</span><span class="p">,</span> <span class="s2">&quot;vew&quot;</span><span class="p">],</span>
        <span class="n">default</span><span class="o">=</span><span class="s2">&quot;merge&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;How to handle mesh boundaries: &#39;merge&#39; to merge nodes, &#39;vew&#39; to use VEW boundaries (default: merge)&quot;</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;--use-land-values&quot;</span><span class="p">,</span>
        <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Use land mesh values at matching nodes (default: use channel mesh values)&quot;</span>
    <span class="p">)</span>
    
    <span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
    
    <span class="c1"># Read the mesh files</span>
    <span class="n">channel_mesh</span> <span class="o">=</span> <span class="n">AdcircMesh</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">channelmesh</span><span class="p">)</span>
    <span class="n">land_mesh</span> <span class="o">=</span> <span class="n">AdcircMesh</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">landmesh</span><span class="p">)</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Successfully read channel mesh from: </span><span class="si">{</span><span class="n">args</span><span class="o">.</span><span class="n">channelmesh</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Successfully read land mesh from: </span><span class="si">{</span><span class="n">args</span><span class="o">.</span><span class="n">landmesh</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1"># Print mesh information</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Channel mesh info:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of nodes: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">channel_mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of elements: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">channel_mesh</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">elements</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Land mesh info:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of nodes: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">land_mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of elements: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">land_mesh</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">elements</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1"># Merge the meshes</span>
    <span class="n">merger</span> <span class="o">=</span> <span class="p">(</span><span class="n">MeshMerger</span><span class="p">(</span><span class="n">channel_mesh</span><span class="p">,</span> <span class="n">land_mesh</span><span class="p">)</span>
                <span class="o">.</span><span class="n">with_tolerance</span><span class="p">(</span><span class="mf">1e-6</span><span class="p">)</span>
                <span class="o">.</span><span class="n">with_height_offset</span><span class="p">(</span><span class="mf">0.001</span><span class="p">)</span>
                <span class="o">.</span><span class="n">with_flow_coefficients</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>
    
    <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">use_land_values</span><span class="p">:</span>
        <span class="n">merger</span><span class="o">.</span><span class="n">with_channel_values</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    
    <span class="n">merged_mesh</span> <span class="o">=</span> <span class="n">merger</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">boundary_mode</span><span class="p">)</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Merged mesh info:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of nodes: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">merged_mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of elements: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">merged_mesh</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">elements</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1"># Save the merged mesh</span>
    <span class="n">merged_mesh</span><span class="o">.</span><span class="n">description</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">description</span>
    <span class="n">merged_mesh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Merged mesh saved to: </span><span class="si">{</span><span class="n">args</span><span class="o">.</span><span class="n">output</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="mi">0</span></div>



<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Shintaro Bunya.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>